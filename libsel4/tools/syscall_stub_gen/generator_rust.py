#
# Copyright (c) 2022 Sam Leffler
# Copyright (c) 2022 Antmicro
#
# SPDX-License-Identifier: BSD-2-Clause
#

from .generator import (
    MAX_MESSAGE_LENGTH,
    Generator,
    is_result_struct_required,
    struct_members,
    get_parameter_positions,
    init_arch_types,
    init_data_types
)


TYPES = {
    8:  "u8",
    16: "u16",
    32: "u32",
    64: "u64"
}


class Type(object):
    """
    This class represents a Rust type (such as an 'u32', structure or
    pointer.
    """

    def __init__(self, name, size_bits, wordsize, *, native_size_bits=None):
        """
        Define a new type, named 'name' that is 'size_bits' bits
        long.
        """
        self.name = name
        self.size_bits = size_bits
        self.wordsize = wordsize
        self.double_word = (size_bits == wordsize*2)

        #
        # Store the number of bits Rust will use for this type
        # in its native unpacked form.
        if native_size_bits:
            self.native_size_bits = native_size_bits
        else:
            self.native_size_bits = size_bits

    def pass_by_reference(self):
        return self.size_bits > self.wordsize and not self.double_word

    def render_parameter_name(self, name):
        """
        Return a string of Rust code that would be used in a function
        parameter declaration.
        """
        name = Generator_Rust.translate_expr(name)
        return "%s: %s" % (name, Generator_Rust.translate_type(self.name))

    def asPointerType(self, mutable):
        """
        Return a new Type class representing a pointer to this object.
        """
        return PointerType(self, self.wordsize, mutable)

    def rust_expression(self, var_name, word_num=0):
        """
        Return code for an expression that gets word 'word_num'
        of this type.
        """
        assert word_num == 0
        return "%s" % var_name

    def double_word_expression(self, var_name, word_num, word_size):

        assert word_num == 0 or word_num == 1

        if word_num == 0:
            return "{1} as {0}".format(TYPES[self.size_bits], var_name)
        elif word_num == 1:
            return "{1}.wrapping_shr({2}) as {0}".format(TYPES[self.size_bits], var_name,
                                                         word_size)


class BitFieldType(Type):
    """
    A special 'struct' generated by the bitfield generator
    """

    def __init__(self, name, size_bits, wordsize):
        super().__init__(name, size_bits, wordsize)

    def rust_expression(self, var_name, word_num=0):
        return "%s.words[%d]" % (var_name, word_num)


class CapType(Type):
    """
    A type that is just a typedef of seL4_CPtr.
    """

    def __init__(self, name, wordsize):
        super().__init__(name, wordsize, wordsize)


class StructType(Type):
    """
    A 'struct' definition.
    """

    def __init__(self, name, size_bits, wordsize):
        super().__init__(name, size_bits, wordsize)

    def rust_expression(self, var_name, word_num, member_name):
        assert word_num < self.size_bits // self.wordsize

        # Multiword structure.
        assert self.pass_by_reference()
        return "(*%s).%s" % (var_name, member_name[word_num])


class PointerType(Type):
    """
    A pointer to a standard type.
    """

    def __init__(self, base_type, wordsize, mutable):
        super().__init__(base_type.name, wordsize, wordsize)
        self.base_type = base_type
        self.mutable = mutable

    def render_parameter_name(self, name):
        return "%s: *%s %s" % (
            Generator_Rust.translate_expr(name),
            "mut" if self.mutable else "const",
            Generator_Rust.translate_type(self.name))

    def rust_expression(self, var_name, word_num=0):
        assert word_num == 0
        return "unsafe { *%s }" % var_name

    def asPointerType(self):
        raise NotImplementedError()


class Generator_Rust(Generator):
    CapType = CapType

    @staticmethod
    def generate_param_list(input_params, output_params):
        # Generate parameters
        params = []
        for param in input_params:
            t = param.type
            if t.pass_by_reference():
                t = t.asPointerType(False)
            params.append(t.render_parameter_name(param.name))
        for param in output_params:
            t = param.type
            if t.pass_by_reference():
                params.append(t.asPointerType(True).render_parameter_name(param.name))
            # else:
            #     raise ValueError(f'Output parameter: {param.name} is passed by value, not by reference.')

        return ", ".join(params)

    @staticmethod
    def translate_expr(name):
        if name == "type":
            return "type_"
        return name

    @staticmethod
    def translate_type(name):
        type_trans = {
            "int": "isize",
            "seL4_Uint8": "u8",
            "seL4_Uint16": "u16",
            "seL4_Uint32": "u32",
            "seL4_Uint64": "u64",
            "seL4_Bool": "u8",
            "seL4_CapData_t": "seL4_CapData",
            "seL4_PrioProps_t": "seL4_PrioProps",
            "seL4_CapRights_t": "seL4_CapRights",
            "seL4_RISCV_Page_GetAddress_t": "seL4_RISCV_Page_GetAddress",
        }
        if name in type_trans:
            return type_trans[name]
        else:
            return name

    def _gen_call(self, service_cap, num_mrs) -> str:
        if self.arch.use_only_ipc_buffer:
            result = "\tlet output_tag = seL4_Call(%s, tag);" % service_cap
        else:
            result = "\tlet output_tag = seL4_CallWithMRs(%s, tag," % (service_cap)
            result += "\t\t%s);" % ', '.join(("&mut mr%d" % i) for i in range(num_mrs))
        self.contents.append(result)
        return result

    def _gen_comment(self, lines, *, doc=False, indent=0, inline=False) -> str:
        begin = "/*"
        if doc:
            begin = "/**"
        tabs = ''
        tabs = ''.join(['\t' + tabs for _ in range(indent)])
        begin = tabs + begin
        if inline:
            comment = [(begin + ' ' + line + ' ' + '*/\n') for line in lines]
        else:
            begin = begin + '\n'
            comment = [begin] + [tabs + " * " + line + "\n" for line in lines] + [tabs + " */"]
        comment = ''.join(comment)
        self.contents.append(comment)
        return comment

    def _gen_conditional_compilation(self, condition) -> str:
        if condition != '':
            # HACK: ugly hacks to handle simple CPP expressions (very fragile)
            NAME_GROUP = r'([a-zA-Z_][a-zA-Z0-9_]*)'
            DEFINE_GROUP = r'defined\(' + NAME_GROUP + '\)'
            import re
            condition = re.sub(r'\!' + DEFINE_GROUP, r'not(feature = "\1")', condition)
            condition = re.sub(DEFINE_GROUP, r'feature = "\1"', condition)
            if ' && ' in condition:
                 condition = 'all(' + condition.replace(' && ', ', ') + ')'
            self.contents.append('#[cfg(' + condition + ')]')
        # No need for "#endif" in rust, so return empty
        return ''

    def _gen_declare_variables(self, returning_struct: bool, return_type, method_id, cap_expressions, input_expressions, num_mrs):
        result = []
        if returning_struct:
            result.append("\tlet mut result: %s = ::core::mem::zeroed();" % return_type)
        result.append("\tlet tag = seL4_MessageInfo::new(InvocationLabel::%s as seL4_Word, 0, %d, %d);" % (
            method_id, len(cap_expressions), len(input_expressions)))
        for i in range(num_mrs):
            result.append("\tlet mut mr%d: seL4_Word = 0;" % i)
        result = '\n'.join(result)
        self.contents.append(result)
        return result

    def _gen_file_footer(self):
        # nothing needed for Rust
        return

    def _gen_file_header(self):
        # nothing needed for Rust
        return

    def _gen_func_header(self, interface_name, method_name, input_params, output_params, return_type) -> str:
        #   static inline int
        #   seL4_Untyped_Retype(...)
        #   {
        #
        result = []
        result.append("#[inline(always)]")
        result.append("#[macros::derive_test_wrapper]")
        result.append("pub unsafe fn %s_%s(%s) -> %s" % (interface_name, method_name,
                                                         type(self).generate_param_list(input_params, output_params), return_type))
        result.append("{")
        result = '\n'.join(result)
        self.contents.append(result)
        return result

    def _gen_init_reg_params(self, i, expression) -> str:
        result = "\tmr%d = %s as seL4_Word;" % (i, expression)
        self.contents.append(result)
        return result

    def _gen_init_buf_params(self, i, expression) -> str:
        expression = self.translate_expr(expression)
        result = "\tseL4_SetMR(%d, %s);" % (i, expression)
        self.contents.append(result)
        return result

    def _gen_result(self, returning_struct: bool, return_type) -> str:
        if returning_struct:
            result = "\tresult.error = output_tag.get_label() as _;"
        else:
            result = "\tlet error: seL4_Error = output_tag.get_label().into();"
        self.contents.append(result)
        return result

    def _gen_result_struct(self, interface_name, method_name, output_params) -> str:
        # Do we actually need a structure?
        if not is_result_struct_required(output_params):
            return ''

        # Generate the structure:
        #
        #   #[repr(C)]
        #   #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #   pub struct seL4_SchedContext_Consumed {
        #       pub error: isize,
        #       pub consumed: seL4_Time,
        #   }

        result = []
        result.append("#[repr(C)]")
        result.append("#[derive(Debug, Clone, Copy, PartialEq, Eq)]")
        result.append("pub struct %s_%s {" % (interface_name, method_name))
        result.append("\tpub error: isize,")
        for i in output_params:
            if not i.type.pass_by_reference():
                result.append("\tpub %s," % i.type.render_parameter_name(i.name))
        result.append("}")
        result.append("")
        result = "\n".join(result)
        self.contents.append(result)
        return result

    def _gen_return_end_function(self, returning_struct) -> str:
        result = "\tresult\n}" if returning_struct else "\terror.into()\n}"
        self.contents.append(result)
        return result

    def _gen_setup_input_capability(self, i, expression) -> str:
        result = "\tseL4_SetCap(%d, %s);" % (i, expression)
        self.contents.append(result)
        return result

    def _gen_unmarshal_regs_into_ipc(self, num_mrs, returning_struct) -> str:
        result = []
        result.append("\tif error != seL4_Error::seL4_NoError {")
        for i in range(num_mrs):
            result.append("\t\tseL4_SetMR(%d, mr%d);" % (i, i))
        if returning_struct:
            result.append("\t\treturn result;")
        else:
            result.append("\t\terror.into()")
        result.append("\t}")  # close 'if () {}'
        result = '\n'.join(result)
        self.contents.append(result)
        return result

    def _gen_unmarshal_result(self, num_mrs, output_params, structs) -> str:
        result = []
        source_words = {}
        for i in range(MAX_MESSAGE_LENGTH):
            if i < num_mrs:
                source_words["w%d" % i] = "mr%d" % i
            else:
                source_words["w%d" % i] = "seL4_GetMR(%d)" % i
        unmashalled_params = self.generate_unmarshal_expressions(output_params)
        for (param, words) in unmashalled_params:
            param.name = self.translate_expr(param.name)
            if param.type.pass_by_reference():
                members = struct_members(param.type, structs)
                for i in range(len(words)):
                    result.append("\t(*%s).%s = %s;" %
                                  (param.name, members[i], words[i] % source_words))
            else:
                if param.type.double_word:
                    result.append("\tresult.%s = (%s as %s) + ((%s as %s).wrapping_shr(32));" %
                                  (param.name, words[0] % source_words, TYPES[64],
                                   words[1] % source_words, TYPES[64]))
                else:
                    for word in words:
                        result.append("\tresult.%s = %s;" %
                                      (param.name, self.construction(word % source_words, param)))
        result = '\n'.join(result)
        self.contents.append(result)
        return result

    def construction(self, expr, param):
        if isinstance(param.type, StructType):
            return "%s { words: [%s] }" % (param.type.name, expr)
        else:
            return "%s as %s" % (expr, self.translate_type(param.type.name))

    def get_func_return_type(self, returning_struct: bool, interface_name, method_name):
        if returning_struct:
            return "%s_%s" % (interface_name, method_name)
        return "seL4_Result"

    def generate_marshal_expressions(self, params, num_mrs, structs):
        wordsize = self.arch.wordsize

        def generate_param_code(param, first_bit, num_bits, word_array, wordsize):
            """
            Generate code to marshal the given parameter into the correct
            location in the message.

            'word_array' is an array of the final contents of the message.
            word_array[k] contains what should be placed in the k'th message
            register, and is an array of expressions that will (eventually)
            be bitwise-or'ed into it.
            """

            target_word = first_bit // wordsize
            target_offset = first_bit % wordsize

            # double word type
            if param.type.double_word:
                word_array[target_word].append(
                    param.type.double_word_expression(param.name, 0, wordsize))
                word_array[target_word +
                           1].append(param.type.double_word_expression(param.name, 1, wordsize))
                return

            # Single full word?
            if num_bits == wordsize:
                assert target_offset == 0
                expr = param.type.rust_expression(param.name)
                word_array[target_word].append(expr)
                return

            # Part of a word?
            if num_bits < wordsize:
                expr = param.type.rust_expression(param.name)
                expr = "(%s & %#x)" % (expr, (1 << num_bits) - 1)
                if target_offset:
                    expr = "(%s as seL4_Word).wrapping_shl(%d)" % (expr, target_offset)
                word_array[target_word].append(expr)
                return

            # Multiword array
            assert target_offset == 0
            num_words = num_bits // wordsize
            for i in range(num_words):
                expr = param.type.rust_expression(
                    param.name, i, struct_members(param.type, structs))
                word_array[target_word + i].append(expr)

        # Get their marshalling positions
        positions = get_parameter_positions(params, wordsize)

        # Generate marshal code.
        words = [[] for _ in range(num_mrs, MAX_MESSAGE_LENGTH)]
        for (param, first_bit, num_bits) in positions:
            generate_param_code(param, first_bit, num_bits, words, wordsize)

        # Return list of expressions.
        return [" | ".join(map(lambda x: "(" + self.translate_expr(x) + " as seL4_Word)", x))
                for x in words if len(x) > 0]

    def generate_unmarshal_expressions(self, params):
        wordsize = self.arch.wordsize

        def unmarshal_single_param(first_bit, num_bits, wordsize):
            """
            Unmarshal a single parameter.
            """
            first_word = first_bit // wordsize
            bit_offset = first_bit % wordsize

            # Multiword type?
            if num_bits > wordsize:
                result = []
                for x in range(num_bits // wordsize):
                    result.append("%%(w%d)s" % (x + first_word))
                return result

            # Otherwise, bit packed.
            if num_bits == wordsize:
                return ["%%(w%d)s" % first_word]
            elif bit_offset == 0:
                return ["(%%(w%d)s & %#x)" % (
                    first_word, (1 << num_bits) - 1)]
            else:
                return ["(%%(w%d)s.wrapping_shr(%d)) & %#x" % (
                    first_word, bit_offset, (1 << num_bits) - 1)]

        # Get their marshalling positions
        positions = get_parameter_positions(params, wordsize)

        # Generate the unmarshal code.
        results = []
        for (param, first_bit, num_bits) in positions:
            results.append((param, unmarshal_single_param(first_bit, num_bits, wordsize)))
        return results

    def init_arch_types(self):
        return init_arch_types(
            self.arch.wordsize,
            self.arch.name,
            CapType,
            StructType,
            Type)

    def init_data_types(self):
        return init_data_types(
            self.arch.wordsize,
            self.arch.name,
            BitFieldType,
            CapType,
            Type)
